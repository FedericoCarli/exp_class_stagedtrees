message(filename)
saveRDS(list(time = time, predict = predict$pred, probability = predict$prob,
cutoff = predict$cutoff), file = filename)
}
}
}
args <- commandArgs(trailingOnly = TRUE)
datasets <- factor(read.table("binary_fast_datasets_names.tsv")[, 1])
source("methods.R")
if (length(args) > 0){
if (base::endsWith(args[1], ".tsv")){
datasets <- read.table(args[1])[,1]
}else{ ## it is the name of a dataset
datasets <- args[1]
}
}
if (length(args) > 1){
torun <- unlist(sapply(args[-1], function(x){
if (base::endsWith(x, "_")){
classifiers[base::startsWith(classifiers, x)]
}else{
x
}
}))
}else{
torun <- classifiers
}
torun
# dir.create("results/", showWarnings = FALSE)
for (d in datasets){
res_path <- paste0("results/",d,"/")
dir.create(res_path, showWarnings = FALSE)
data <- readRDS(paste0("datasets/", d, ".rds"))
split_path <- paste0("splits/", d, "/")
for (r in 6:7){
id_test <- readRDS(paste0(split_path, r, "_id_test.rds"))
train <- data[-id_test,]
test <- data[id_test,]
for (c_name in torun){
message(c_name)
c_fun <- get(c_name)
time <- system.time(predict <- c_fun(train, test, optimizecutoff = TRUE))[3]
filename <- paste0(res_path, c_name, "_", r, ".rds")
message(filename)
saveRDS(list(time = time, predict = predict$pred, probability = predict$prob,
cutoff = predict$cutoff), file = filename)
}
}
}
# dir.create("results/", showWarnings = FALSE)
for (d in datasets){
res_path <- paste0("results/",d,"/")
dir.create(res_path, showWarnings = FALSE)
data <- readRDS(paste0("datasets/", d, ".rds"))
split_path <- paste0("splits/", d, "/")
for (r in 8:9){
id_test <- readRDS(paste0(split_path, r, "_id_test.rds"))
train <- data[-id_test,]
test <- data[id_test,]
for (c_name in torun){
message(c_name)
c_fun <- get(c_name)
time <- system.time(predict <- c_fun(train, test, optimizecutoff = TRUE))[3]
filename <- paste0(res_path, c_name, "_", r, ".rds")
message(filename)
saveRDS(list(time = time, predict = predict$pred, probability = predict$prob,
cutoff = predict$cutoff), file = filename)
}
}
}
datasets
source("statistics.R")
# k <- 5
nreps <- 9
source("statistics.R")
TABLE <- array(
data = NA,
dim = c(
length(statistics) - 1,
length(datasets),
length(classifiers),
nreps
),
dimnames = list(
stat = statistics[-length(statistics)],
data = datasets,
classifier = classifiers,
rep = 1:nreps
)
)
ROC_CURVE <- array(
data = rep(NA, 200),
dim = c(
2,
length(datasets),
length(classifiers),
nreps,
200  # we have to store multiple values of specificities and sensitivities to plot Roc Curves.
),
dimnames = list(
stat = c("specificities", "sensitivities"),
data = datasets,
classifier = classifiers,
rep = 1:nreps,
values = 1:200
)
)
for (d in datasets) {
res_path <- paste0("results/", d, "/")
data <- readRDS(paste0("datasets/", d, ".rds"))
split_path <- paste0("splits/", d, "/")
for (r in 1:nreps) {
id_test <- readRDS(paste0(split_path, r, "_id_test.rds"))
true <- data$answer[id_test]
for (c_name in classifiers) {
filename <- paste0(res_path, c_name, "_", r, ".rds" )
if (file.exists(filename)){
res <- readRDS(filename)
for (stat in statistics[-length(statistics)]){
stat_fun <- get(stat)
TABLE[stat, d, c_name, r] <- stat_fun(res, true)
}
stat_fun <- get(statistics[length(statistics)])
auxiliar <- matrix(unlist(stat_fun(res, true)), nrow = 2, byrow = TRUE)
ROC_CURVE[1:2, d, c_name, r, 1:NCOL(auxiliar)] <- auxiliar
}
}
}
}
saveRDS(TABLE, "TABLE.rds")
saveRDS(ROC_CURVE, "ROC_CURVE.rds")
library(ggplot2)
library(data.table)
constantwise_function <- function(x, x.val, y.val) {
x.val <- sort(as.numeric(na.exclude(1 - x.val)))
y.val <- sort(as.numeric(na.exclude(y.val)))
out <- 0
for(i in 1:(length(x.val) - 1)) {
if(x > x.val[i] & x <= x.val[i+1]) {
out <- ((y.val[i] - y.val[i+1]) / (x.val[i] - x.val[i+1])) * x + y.val[i] -
((y.val[i] - y.val[i+1]) / (x.val[i] - x.val[i+1])) * x.val[i]
}
}
return(out)
}
constantwise_function <- Vectorize(constantwise_function, "x")
interpolation <- function(x.val, y.val) {
y <- NULL
count <- 0
for(i in c(seq(0, 0.3, length.out = 70), seq(0.3, 0.8, length.out = 24),
seq(0.8, 1, length.out = 24))) {
count <- count + 1
y[count] <- constantwise_function(i, x.val, y.val)
}
return(c(0, y, 1))
}
interpolated_sensitivity <- array(
data = rep(NA, 120),
dim = c(
length(datasets),
length(classifiers),
nreps,
120  # we have to store multiple values of specificities and sensitivities to plot Roc Curves
),
dimnames = list(
data = datasets,
classifier = classifiers,
rep = 1:nreps,
values = 1:120
)
)
nreps
for(i in 1:length(datasets)) {
for(j in 1:length(classifiers)) {
for(k in 1:nreps) {
interpolated_sensitivity[i, j, k, ] <- interpolation(ROC_CURVE[1, i, j, k, ], ROC_CURVE[2, i, j, k, ])
}
}
}
# they are the same for all roc curve, so now it is reasonable to compute the mean between bootstrap iterations.
fixed_specificities <- c(0, seq(0, 0.3, length.out = 70), seq(0.3, 0.8, length.out = 24),
seq(0.8, 1, length.out = 24), 1)
AVG_ROC_CURVE <- apply(interpolated_sensitivity, c(1,2,4), mean)
saveRDS(AVG_ROC_CURVE, "AVG_ROC_CURVE.rds")
pdf("roc_curves1.pdf")
par(mfrow = c(2, 2))
colors <- rainbow(length(classifiers) - 1)
for(j in 1:4) {
plot(fixed_specificities, AVG_ROC_CURVE[j, 1, ], lwd = 0.5,
type = "l", xlab = "1 - Specificity", ylab = "Sensitivity",
main = attr(AVG_ROC_CURVE, "dimnames")$data[j], xlim = c(0, 1), ylim = c(0, 1))
for(i in 2:length(classifiers)) {
points(fixed_specificities, AVG_ROC_CURVE[j, i, ], lwd = 0.5, col = colors[i-1], type = "l")
}
}
dev.off()
pdf("roc_curves2.pdf")
par(mfrow = c(2, 2))
colors <- rainbow(length(classifiers) - 1)
for(j in 5:8) {
plot(fixed_specificities, AVG_ROC_CURVE[j, 1, ], lwd = 0.5,
type = "l", xlab = "1 - Specificity", ylab = "Sensitivity",
main = attr(AVG_ROC_CURVE, "dimnames")$data[j], xlim = c(0, 1), ylim = c(0, 1))
for(i in 2:length(classifiers)) {
points(fixed_specificities, AVG_ROC_CURVE[j, i, ], lwd = 0.5, col = colors[i-1], type = "l")
}
}
dev.off()
pdf("roc_curves3.pdf")
par(mfrow = c(2, 2))
colors <- rainbow(length(classifiers) - 1)
for(j in 9:12) {
plot(fixed_specificities, AVG_ROC_CURVE[j, 1, ], lwd = 0.5,
type = "l", xlab = "1 - Specificity", ylab = "Sensitivity",
main = attr(AVG_ROC_CURVE, "dimnames")$data[j], xlim = c(0, 1), ylim = c(0, 1))
for(i in 2:length(classifiers)) {
points(fixed_specificities, AVG_ROC_CURVE[j, i, ], lwd = 0.5, col = colors[i-1], type = "l")
}
}
dev.off()
pdf("roc_curves4.pdf")
par(mfrow = c(2, 2))
colors <- rainbow(length(classifiers) - 1)
for(j in 13:15) {
plot(fixed_specificities, AVG_ROC_CURVE[j, 1, ], lwd = 0.5,
type = "l", xlab = "1 - Specificity", ylab = "Sensitivity",
main = attr(AVG_ROC_CURVE, "dimnames")$data[j], xlim = c(0, 1), ylim = c(0, 1))
for(i in 2:length(classifiers)) {
points(fixed_specificities, AVG_ROC_CURVE[j, i, ], lwd = 0.5, col = colors[i-1], type = "l")
}
}
dev.off()
## compute averages
AVG <- apply(TABLE, c(1,2,3), mean, na.rm = TRUE)
## transform to data.table
data <- as.data.table(AVG)
## plot accuracies
ggplot(data = data[stat %in% c("accuracy", "balanced_accuracy") & classifier %in% classifiers], aes(y = data, x = value,
group = classifier, color = classifier)) +
geom_jitter(height = 0.2, width = 0, alpha = 0.5) + facet_grid(cols = vars(stat), scales = "free") +
theme_bw() +
theme(
legend.position = "top",
legend.title = element_blank(),
axis.title.y = element_blank(),
axis.text.x = element_text(angle = 30),
legend.box.spacing = unit(0.5, "lines"),
legend.box.margin = ggplot2::margin(
t = 0,
r = 5,
b = 0,
l = 0,
unit = "pt"
),
plot.margin = ggplot2::margin(
t = 0,
r = 5,
b = 0,
l = 0,
unit = "pt"
)
) + xlab("") +
ggsave("plot_accuracy.pdf", width = 7, height = 6, units = "in")
## plot time
ggplot(data = data[stat == "time" & classifier %in% classifiers], aes(y = data, x = value,
group = classifier, color = classifier)) +
geom_jitter(height = 0.2, alpha = 0.5) +
theme_bw() +
scale_x_log10()+
theme(
legend.position = "top",
legend.title = element_blank(),
axis.title.y = element_blank(),
axis.text.x = element_text(angle = 30),
legend.box.spacing = unit(0.5, "lines"),
legend.box.margin = ggplot2::margin(
t = 0,
r = 15,
b = 0,
l = 0,
unit = "pt"
),
plot.margin = ggplot2::margin(
t = 0,
r = 15,
b = 0,
l = 0,
unit = "pt"
)
) + guides(color=guide_legend(nrow=3,byrow=TRUE)) +
xlab("seconds") +
ggsave("plot_time.pdf", width = 5, height = 6, units = "in")
## plot spec - sens - fp - fn
ggplot(data = data[stat %in% c("sens", "fn", "spec", "fp") & classifier %in% classifiers], aes(y = data, x = value,
group = classifier, color = classifier)) +
geom_jitter(height = 0.2, width = 0, alpha = 0.5) + facet_grid(cols = vars(stat), scales = "free") +
theme_bw() +
theme(
legend.position = "top",
legend.title = element_blank(),
axis.title.y = element_blank(),
axis.text.x = element_text(angle = 30),
legend.box.spacing = unit(0.5, "lines"),
legend.box.margin = ggplot2::margin(
t = 0,
r = 5,
b = 0,
l = 0,
unit = "pt"
),
plot.margin = ggplot2::margin(
t = 0,
r = 5,
b = 0,
l = 0,
unit = "pt"
)
) + xlab("") +
ggsave("plot_confusion_matrix.pdf", width = 7, height = 6, units = "in")
## plot auc - cutoff - precision - f1
ggplot(data = data[stat %in% c("auc", "cutoff", "precision", "f1") & classifier %in% classifiers], aes(y = data, x = value,
group = classifier, color = classifier)) +
geom_jitter(height = 0.2, width = 0, alpha = 0.5) + facet_grid(cols = vars(stat), scales = "free") +
theme_bw() +
theme(
legend.position = "top",
legend.title = element_blank(),
axis.title.y = element_blank(),
axis.text.x = element_text(angle = 30),
legend.box.spacing = unit(0.5, "lines"),
legend.box.margin = ggplot2::margin(
t = 0,
r = 5,
b = 0,
l = 0,
unit = "pt"
),
plot.margin = ggplot2::margin(
t = 0,
r = 5,
b = 0,
l = 0,
unit = "pt"
)
) + xlab("") +
ggsave("plot_auc_cutoff_precision_f1.pdf", width = 7, height = 6, units = "in")
str(AVG_ROC_CURVE)
attr(AVG_ROC_CURVE, "dimnames")$classifier
pdf("roc_curves1_hc_indep.pdf")
par(mfrow = c(2, 2))
# colors <- rainbow(length(classifiers) - 1)
for(j in 1:4) {
plot(fixed_specificities, AVG_ROC_CURVE[j, 9, ], lwd = 0.5,
type = "l", xlab = "1 - Specificity", ylab = "Sensitivity",
main = attr(AVG_ROC_CURVE, "dimnames")$data[j], xlim = c(0, 1), ylim = c(0, 1))
for(i in 10:16) {
points(fixed_specificities, AVG_ROC_CURVE[j, i, ], lwd = 0.5, col = i, type = "l")
}
}
dev.off()
seq_along(10)
seq_along(100)
seq_along(c(1,10))
seq_along(c(1,100))
seq_along(c(1000,100))
# dir.create("results/", showWarnings = FALSE)
for (d in datasets){
res_path <- paste0("results/",d,"/")
dir.create(res_path, showWarnings = FALSE)
data <- readRDS(paste0("datasets/", d, ".rds"))
split_path <- paste0("splits/", d, "/")
for (r in 10){
id_test <- readRDS(paste0(split_path, r, "_id_test.rds"))
train <- data[-id_test,]
test <- data[id_test,]
for (c_name in torun){
message(c_name)
c_fun <- get(c_name)
time <- system.time(predict <- c_fun(train, test, optimizecutoff = TRUE))[3]
filename <- paste0(res_path, c_name, "_", r, ".rds")
message(filename)
saveRDS(list(time = time, predict = predict$pred, probability = predict$prob,
cutoff = predict$cutoff), file = filename)
}
}
}
load("~/Desktop/Miniclip - Challenge/data/challenge_no_goldenspin.RData")
head(users_dataset, 50)
View(users_dataset)
View(users_dataset)
summary(users_dataset)
users_dataset[20:30, ]
View(users_dataset)
exp(0.38)
exp(-0.67)
3.44*1.46
str(app_purchases)
0.03*61000
args <- commandArgs(trailingOnly = TRUE)
datasets <- factor(read.table("binary_fast_datasets_names.tsv")[, 1])
source("methods.R")
if (length(args) > 0){
if (base::endsWith(args[1], ".tsv")){
datasets <- read.table(args[1])[,1]
}else{ ## it is the name of a dataset
datasets <- args[1]
}
}
if (length(args) > 1){
torun <- unlist(sapply(args[-1], function(x){
if (base::endsWith(x, "_")){
classifiers[base::startsWith(classifiers, x)]
}else{
x
}
}))
}else{
torun <- classifiers
}
nreps <- 10
dir.create("results_no_cutoff/", showWarnings = FALSE)
dir.create("results_no_cutoff/", showWarnings = FALSE)
for (d in datasets){
res_path <- paste0("results_no_cutoff/",d,"/")
dir.create(res_path, showWarnings = FALSE)
data <- readRDS(paste0("datasets/", d, ".rds"))
split_path <- paste0("splits/", d, "/")
for (r in 1:2){
id_test <- readRDS(paste0(split_path, r, "_id_test.rds"))
train <- data[-id_test,]
test <- data[id_test,]
for (c_name in torun){
message(c_name)
c_fun <- get(c_name)
time <- system.time(predict <- c_fun(train, test, optimizecutoff = FALSE))[3]
filename <- paste0(res_path, c_name, "_", r, ".rds")
message(filename)
saveRDS(list(time = time, predict = predict$pred, probability = predict$prob,
cutoff = predict$cutoff), file = filename)
}
}
}
x<-c(2,3,4,5)
x[-c(1,0,0,0)]
x[-c(1,2,3,4)]
x[c(-1,2,3,4)]
cor.test(train$answer, train$Class)
cor.test(as.numeric(train$answer), as.numeric(train$Class))
cor.test(as.numeric(train$answer), as.numeric(train$Class), train)
x<-NA
y <- x / 1
y
x <- matrix(1:6, nrow = 3)
x
x <- as.data.frame(x)
merge(x, x)
y <- x
merge(x, y)
x <- as.Date("2018-10-01")
x
month(x)
months(x)
x <- list(1,2,"C",4,5)
unlist(x)
x<-1:3
names(x) <- c("a", "b", "c")
x
x[4] <- -4
x
names(x[4])
x <- matrix(1:6, nrow = 3)
y<-as.data.frame(x)
str(cbind(x,y))
x <- 5:8
names(x) <- letters[5:8]
x
rm(x)
rm(y)
2100/60
load("~/Desktop/Swiss Re/AlessandroUgolini/Stesura Paper/codice completo.RData")
cbind(all$n_carie_1 + all$notturazioni_1, all$n_carie_3 + all$notturazioni_3)
foo <- cbind(all$n_carie_1 + all$notturazioni_1, all$n_carie_3 + all$notturazioni_3)
foo[foo[, 1] > 0]
foo[foo[, 1] > 0, ]
table(all$origine_etnica)
table(all$origine_etnica > 0)
table(all$origine_etnica )>0
table(all$origine_etnica )[table(all$origine_etnica )>0]
str(all)
library(bnlearn)
bn0 <- bn(dati)
library(bnlearn)
bn0 <- bn.fit(dati)
bn0 <- tabu(dati)
bn0_fit <- bn.fit(bn0, dati)
plot(bn0)
bn0
bn0 <- hc(dati)
bn0_fit <- bn.fit(bn0, dati)
plot(bn0)
bn0.grain <- as(amat(bn0), "graphNEL")
bn0.grain <- as(amat(bn0_fit), "graphNEL")
amat(bn0)
as(amat(bn0), "graphNEL")
bn0.grain <- amat(bn0)
bn0.grain <- grain(bn0.grain, data=dati)
library(ggm)
bn0.grain <- amat(bn0)
bn0.grain <- grain(bn0.grain, data=dati)
library(gRain)
bn0.grain <- grain(bn0.grain, data=dati)
bn0.grain
